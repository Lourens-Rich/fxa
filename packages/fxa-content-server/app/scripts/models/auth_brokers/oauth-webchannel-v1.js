/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/**
 * WebChannel OAuth broker that speaks "v1" of the protocol.
 */

import _ from 'underscore';
import WebChannel from '../../lib/channels/web';
import Constants from '../../lib/constants';
import HaltIfBrowserTransitions from '../../views/behaviors/halt-if-browser-transitions';
import FxSyncWebChannelAuthenticationBroker from './fx-sync-web-channel';

const proto = FxSyncWebChannelAuthenticationBroker.prototype;
const defaultBehaviors = proto.defaultBehaviors;

/**
 * Invoke `brokerMethod` on the broker and finish the OAuth flow by
 * invoking `finishMethod` if verifying in the original tab. If verifying
 * in another tab, the default behavior is returned.
 *
 * @param {String} brokerMethod
 * @param {String} finishMethod
 * @returns {Promise}
 */
function finishOAuthFlowIfOriginalTab(brokerMethod, finishMethod) {
  return function(account) {
    // The user may have replaced the original tab with the verification
    // tab. If this is the case, send the OAuth result to the RP.
    //
    // The slight delay is to allow the functional tests time to bind
    // event handlers before the flow completes.
    return proto[brokerMethod]
      .call(this, account)
      .then(behavior => {
        return p.delay(this.DELAY_BROKER_RESPONSE_MS).then(() => behavior);
      })
      .then(behavior => {
        if (this.isOriginalTab()) {
          return this[finishMethod](account).then(() => new HaltBehavior());
        }
        return behavior;
      });
  };
}

const OAuthWebChannelBroker = FxSyncWebChannelAuthenticationBroker.extend({
  defaultBehaviors: _.extend({}, defaultBehaviors, {
    // afterForceAuth: new HaltIfBrowserTransitions(
    //   defaultBehaviors.afterForceAuth
    // ),
    // afterResetPasswordConfirmationPoll: new HaltIfBrowserTransitions(
    //   defaultBehaviors.afterResetPasswordConfirmationPoll
    // ),
    // afterSignIn: new HaltIfBrowserTransitions(defaultBehaviors.afterSignIn),
    // afterSignInConfirmationPoll: new HaltIfBrowserTransitions(
    //   defaultBehaviors.afterSignInConfirmationPoll
    // ),
    // afterSignUpConfirmationPoll: new HaltIfBrowserTransitions(
    //   defaultBehaviors.afterSignUpConfirmationPoll
    // ),
  }),

  defaultCapabilities: _.extend({}, proto.defaultCapabilities, {
    allowUidChange: true,
    emailFirst: true,
    tokenCode: false,
  }),

  commands: _.pick(
    WebChannel,
    'CAN_LINK_ACCOUNT',
    'CHANGE_PASSWORD',
    'DELETE_ACCOUNT',
    'LOADED',
    'LOGIN',
    'VERIFIED'
  ),

  type: 'oauth-webchannel-v1',

  createChannel() {
    const channel = new WebChannel(Constants.ACCOUNT_UPDATES_WEBCHANNEL_ID);
    channel.initialize({
      window: this.window,
    });

    return channel;
  },

  afterCompleteResetPassword(account) {
    // This method is not in the fx-sync-channel because only the initiating
    // tab can send a login message for fx-desktop-v1 and it's descendents.
    // Messages from other tabs are ignored.
    return Promise.resolve()
      .then(() => {
        if (
          account.get('verified') &&
          !account.get('verificationReason') &&
          !account.get('verificationMethod')
        ) {
          // only notify the browser of the login if the user does not have
          // to verify their account/session
          return this._notifyRelierOfLogin(account);
        }
      })
      .then(() => proto.afterCompleteResetPassword.call(this, account));
  },

  afterCompleteSignInWithCode(account) {
    return this._notifyRelierOfLogin(account).then(() =>
      proto.afterSignInConfirmationPoll.call(this, account)
    );
  },

  beforeSignUpConfirmationPoll(account) {
    // The Sync broker notifies the browser of an unverified login
    // before the user has verified their email. This allows the user
    // to close the original tab or open the verification link in
    // the about:accounts tab and have Sync still successfully start.
    return this._notifyRelierOfLogin(account).then(() =>
      proto.beforeSignUpConfirmationPoll.call(this, account)
    );
  },

  /**
   * Finish the OAuth flow.
   *
   * @param {Object} [result] - state sent by OAuth RP
   * @param {String} [result.state] - state sent by OAuth RP
   * @param {String} [result.code] - OAuth code generated by the OAuth server
   * @param {String} [result.redirect] - URL that can be used to redirect to
   * the RP.
   *
   * @returns {Promise}
   */

  finishOAuthSignInFlow(account) {
    return this.finishOAuthFlow(account, {
      action: Constants.OAUTH_ACTION_SIGNIN,
    });
  },

  finishOAuthSignUpFlow(account) {
    return this.finishOAuthFlow(account, {
      action: Constants.OAUTH_ACTION_SIGNUP,
    });
  },

  finishOAuthFlow(account, additionalResultData) {
    this.session.clear('oauth');

    return Promise.resolve().then(() => {
      // There are no ill side effects if the Original Tab Marker is
      // cleared in the a tab other than the original. Always clear it just
      // to make sure the bases are covered.
      this.clearOriginalTabMarker();
      return this.getOAuthResult(account).then(result => {
        result = _.extend(result, additionalResultData);
        return this.sendOAuthResultToRelier(result);
      });
    });
  },

  afterCompleteSignUp: finishOAuthFlowIfOriginalTab(
    'afterCompleteSignUp',
    'finishOAuthSignUpFlow'
  ),
});

export default OAuthWebChannelBroker;
